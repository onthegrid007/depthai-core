// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SpatialImgDetections.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SpatialImgDetections_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SpatialImgDetections_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ImgDetections.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SpatialImgDetections_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SpatialImgDetections_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SpatialImgDetections_2eproto;
namespace proto {
class Point3f;
struct Point3fDefaultTypeInternal;
extern Point3fDefaultTypeInternal _Point3f_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class SpatialImgDetection;
struct SpatialImgDetectionDefaultTypeInternal;
extern SpatialImgDetectionDefaultTypeInternal _SpatialImgDetection_default_instance_;
class SpatialImgDetections;
struct SpatialImgDetectionsDefaultTypeInternal;
extern SpatialImgDetectionsDefaultTypeInternal _SpatialImgDetections_default_instance_;
class SpatialLocationCalculatorConfigData;
struct SpatialLocationCalculatorConfigDataDefaultTypeInternal;
extern SpatialLocationCalculatorConfigDataDefaultTypeInternal _SpatialLocationCalculatorConfigData_default_instance_;
class SpatialLocationCalculatorConfigThresholds;
struct SpatialLocationCalculatorConfigThresholdsDefaultTypeInternal;
extern SpatialLocationCalculatorConfigThresholdsDefaultTypeInternal _SpatialLocationCalculatorConfigThresholds_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::Point3f* Arena::CreateMaybeMessage<::proto::Point3f>(Arena*);
template<> ::proto::Rect* Arena::CreateMaybeMessage<::proto::Rect>(Arena*);
template<> ::proto::SpatialImgDetection* Arena::CreateMaybeMessage<::proto::SpatialImgDetection>(Arena*);
template<> ::proto::SpatialImgDetections* Arena::CreateMaybeMessage<::proto::SpatialImgDetections>(Arena*);
template<> ::proto::SpatialLocationCalculatorConfigData* Arena::CreateMaybeMessage<::proto::SpatialLocationCalculatorConfigData>(Arena*);
template<> ::proto::SpatialLocationCalculatorConfigThresholds* Arena::CreateMaybeMessage<::proto::SpatialLocationCalculatorConfigThresholds>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum SpatialLocationCalculatorAlgorithm : int {
  AVERAGE = 0,
  MEAN = 0,
  MIN = 1,
  MAX = 2,
  MODE = 3,
  MEDIAN = 4,
  SpatialLocationCalculatorAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpatialLocationCalculatorAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpatialLocationCalculatorAlgorithm_IsValid(int value);
constexpr SpatialLocationCalculatorAlgorithm SpatialLocationCalculatorAlgorithm_MIN = AVERAGE;
constexpr SpatialLocationCalculatorAlgorithm SpatialLocationCalculatorAlgorithm_MAX = MEDIAN;
constexpr int SpatialLocationCalculatorAlgorithm_ARRAYSIZE = SpatialLocationCalculatorAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpatialLocationCalculatorAlgorithm_descriptor();
template<typename T>
inline const std::string& SpatialLocationCalculatorAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpatialLocationCalculatorAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpatialLocationCalculatorAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpatialLocationCalculatorAlgorithm_descriptor(), enum_t_value);
}
inline bool SpatialLocationCalculatorAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpatialLocationCalculatorAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpatialLocationCalculatorAlgorithm>(
    SpatialLocationCalculatorAlgorithm_descriptor(), name, value);
}
// ===================================================================

class SpatialImgDetections final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SpatialImgDetections) */ {
 public:
  inline SpatialImgDetections() : SpatialImgDetections(nullptr) {}
  ~SpatialImgDetections() override;
  explicit constexpr SpatialImgDetections(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpatialImgDetections(const SpatialImgDetections& from);
  SpatialImgDetections(SpatialImgDetections&& from) noexcept
    : SpatialImgDetections() {
    *this = ::std::move(from);
  }

  inline SpatialImgDetections& operator=(const SpatialImgDetections& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatialImgDetections& operator=(SpatialImgDetections&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpatialImgDetections& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpatialImgDetections* internal_default_instance() {
    return reinterpret_cast<const SpatialImgDetections*>(
               &_SpatialImgDetections_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SpatialImgDetections& a, SpatialImgDetections& b) {
    a.Swap(&b);
  }
  inline void Swap(SpatialImgDetections* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpatialImgDetections* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpatialImgDetections* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpatialImgDetections>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpatialImgDetections& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpatialImgDetections& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialImgDetections* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SpatialImgDetections";
  }
  protected:
  explicit SpatialImgDetections(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionsFieldNumber = 4,
    kTsFieldNumber = 2,
    kTsDeviceFieldNumber = 3,
    kSequenceNumFieldNumber = 1,
  };
  // repeated .proto.SpatialImgDetection detections = 4;
  int detections_size() const;
  private:
  int _internal_detections_size() const;
  public:
  void clear_detections();
  ::proto::SpatialImgDetection* mutable_detections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SpatialImgDetection >*
      mutable_detections();
  private:
  const ::proto::SpatialImgDetection& _internal_detections(int index) const;
  ::proto::SpatialImgDetection* _internal_add_detections();
  public:
  const ::proto::SpatialImgDetection& detections(int index) const;
  ::proto::SpatialImgDetection* add_detections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SpatialImgDetection >&
      detections() const;

  // .proto.Timestamp ts = 2;
  bool has_ts() const;
  private:
  bool _internal_has_ts() const;
  public:
  void clear_ts();
  const ::proto::Timestamp& ts() const;
  PROTOBUF_NODISCARD ::proto::Timestamp* release_ts();
  ::proto::Timestamp* mutable_ts();
  void set_allocated_ts(::proto::Timestamp* ts);
  private:
  const ::proto::Timestamp& _internal_ts() const;
  ::proto::Timestamp* _internal_mutable_ts();
  public:
  void unsafe_arena_set_allocated_ts(
      ::proto::Timestamp* ts);
  ::proto::Timestamp* unsafe_arena_release_ts();

  // .proto.Timestamp tsDevice = 3;
  bool has_tsdevice() const;
  private:
  bool _internal_has_tsdevice() const;
  public:
  void clear_tsdevice();
  const ::proto::Timestamp& tsdevice() const;
  PROTOBUF_NODISCARD ::proto::Timestamp* release_tsdevice();
  ::proto::Timestamp* mutable_tsdevice();
  void set_allocated_tsdevice(::proto::Timestamp* tsdevice);
  private:
  const ::proto::Timestamp& _internal_tsdevice() const;
  ::proto::Timestamp* _internal_mutable_tsdevice();
  public:
  void unsafe_arena_set_allocated_tsdevice(
      ::proto::Timestamp* tsdevice);
  ::proto::Timestamp* unsafe_arena_release_tsdevice();

  // int64 sequenceNum = 1;
  void clear_sequencenum();
  int64_t sequencenum() const;
  void set_sequencenum(int64_t value);
  private:
  int64_t _internal_sequencenum() const;
  void _internal_set_sequencenum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SpatialImgDetections)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SpatialImgDetection > detections_;
  ::proto::Timestamp* ts_;
  ::proto::Timestamp* tsdevice_;
  int64_t sequencenum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SpatialImgDetections_2eproto;
};
// -------------------------------------------------------------------

class SpatialImgDetection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SpatialImgDetection) */ {
 public:
  inline SpatialImgDetection() : SpatialImgDetection(nullptr) {}
  ~SpatialImgDetection() override;
  explicit constexpr SpatialImgDetection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpatialImgDetection(const SpatialImgDetection& from);
  SpatialImgDetection(SpatialImgDetection&& from) noexcept
    : SpatialImgDetection() {
    *this = ::std::move(from);
  }

  inline SpatialImgDetection& operator=(const SpatialImgDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatialImgDetection& operator=(SpatialImgDetection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpatialImgDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpatialImgDetection* internal_default_instance() {
    return reinterpret_cast<const SpatialImgDetection*>(
               &_SpatialImgDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpatialImgDetection& a, SpatialImgDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(SpatialImgDetection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpatialImgDetection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpatialImgDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpatialImgDetection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpatialImgDetection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpatialImgDetection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialImgDetection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SpatialImgDetection";
  }
  protected:
  explicit SpatialImgDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionFieldNumber = 1,
    kSpatialCoordinatesFieldNumber = 2,
    kBoundingBoxMappingFieldNumber = 3,
  };
  // .proto.ImgDetection detection = 1;
  bool has_detection() const;
  private:
  bool _internal_has_detection() const;
  public:
  void clear_detection();
  const ::proto::ImgDetection& detection() const;
  PROTOBUF_NODISCARD ::proto::ImgDetection* release_detection();
  ::proto::ImgDetection* mutable_detection();
  void set_allocated_detection(::proto::ImgDetection* detection);
  private:
  const ::proto::ImgDetection& _internal_detection() const;
  ::proto::ImgDetection* _internal_mutable_detection();
  public:
  void unsafe_arena_set_allocated_detection(
      ::proto::ImgDetection* detection);
  ::proto::ImgDetection* unsafe_arena_release_detection();

  // .proto.Point3f spatialCoordinates = 2;
  bool has_spatialcoordinates() const;
  private:
  bool _internal_has_spatialcoordinates() const;
  public:
  void clear_spatialcoordinates();
  const ::proto::Point3f& spatialcoordinates() const;
  PROTOBUF_NODISCARD ::proto::Point3f* release_spatialcoordinates();
  ::proto::Point3f* mutable_spatialcoordinates();
  void set_allocated_spatialcoordinates(::proto::Point3f* spatialcoordinates);
  private:
  const ::proto::Point3f& _internal_spatialcoordinates() const;
  ::proto::Point3f* _internal_mutable_spatialcoordinates();
  public:
  void unsafe_arena_set_allocated_spatialcoordinates(
      ::proto::Point3f* spatialcoordinates);
  ::proto::Point3f* unsafe_arena_release_spatialcoordinates();

  // .proto.SpatialLocationCalculatorConfigData boundingBoxMapping = 3;
  bool has_boundingboxmapping() const;
  private:
  bool _internal_has_boundingboxmapping() const;
  public:
  void clear_boundingboxmapping();
  const ::proto::SpatialLocationCalculatorConfigData& boundingboxmapping() const;
  PROTOBUF_NODISCARD ::proto::SpatialLocationCalculatorConfigData* release_boundingboxmapping();
  ::proto::SpatialLocationCalculatorConfigData* mutable_boundingboxmapping();
  void set_allocated_boundingboxmapping(::proto::SpatialLocationCalculatorConfigData* boundingboxmapping);
  private:
  const ::proto::SpatialLocationCalculatorConfigData& _internal_boundingboxmapping() const;
  ::proto::SpatialLocationCalculatorConfigData* _internal_mutable_boundingboxmapping();
  public:
  void unsafe_arena_set_allocated_boundingboxmapping(
      ::proto::SpatialLocationCalculatorConfigData* boundingboxmapping);
  ::proto::SpatialLocationCalculatorConfigData* unsafe_arena_release_boundingboxmapping();

  // @@protoc_insertion_point(class_scope:proto.SpatialImgDetection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::proto::ImgDetection* detection_;
  ::proto::Point3f* spatialcoordinates_;
  ::proto::SpatialLocationCalculatorConfigData* boundingboxmapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SpatialImgDetections_2eproto;
};
// -------------------------------------------------------------------

class Point3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Point3f) */ {
 public:
  inline Point3f() : Point3f(nullptr) {}
  ~Point3f() override;
  explicit constexpr Point3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point3f(const Point3f& from);
  Point3f(Point3f&& from) noexcept
    : Point3f() {
    *this = ::std::move(from);
  }

  inline Point3f& operator=(const Point3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point3f& operator=(Point3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point3f* internal_default_instance() {
    return reinterpret_cast<const Point3f*>(
               &_Point3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Point3f& a, Point3f& b) {
    a.Swap(&b);
  }
  inline void Swap(Point3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point3f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Point3f";
  }
  protected:
  explicit Point3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Point3f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SpatialImgDetections_2eproto;
};
// -------------------------------------------------------------------

class SpatialLocationCalculatorConfigData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SpatialLocationCalculatorConfigData) */ {
 public:
  inline SpatialLocationCalculatorConfigData() : SpatialLocationCalculatorConfigData(nullptr) {}
  ~SpatialLocationCalculatorConfigData() override;
  explicit constexpr SpatialLocationCalculatorConfigData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpatialLocationCalculatorConfigData(const SpatialLocationCalculatorConfigData& from);
  SpatialLocationCalculatorConfigData(SpatialLocationCalculatorConfigData&& from) noexcept
    : SpatialLocationCalculatorConfigData() {
    *this = ::std::move(from);
  }

  inline SpatialLocationCalculatorConfigData& operator=(const SpatialLocationCalculatorConfigData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatialLocationCalculatorConfigData& operator=(SpatialLocationCalculatorConfigData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpatialLocationCalculatorConfigData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpatialLocationCalculatorConfigData* internal_default_instance() {
    return reinterpret_cast<const SpatialLocationCalculatorConfigData*>(
               &_SpatialLocationCalculatorConfigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SpatialLocationCalculatorConfigData& a, SpatialLocationCalculatorConfigData& b) {
    a.Swap(&b);
  }
  inline void Swap(SpatialLocationCalculatorConfigData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpatialLocationCalculatorConfigData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpatialLocationCalculatorConfigData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpatialLocationCalculatorConfigData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpatialLocationCalculatorConfigData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpatialLocationCalculatorConfigData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialLocationCalculatorConfigData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SpatialLocationCalculatorConfigData";
  }
  protected:
  explicit SpatialLocationCalculatorConfigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoiFieldNumber = 1,
    kDepthThresholdsFieldNumber = 2,
    kCalculationAlgorithmFieldNumber = 3,
    kStepSizeFieldNumber = 4,
  };
  // .proto.Rect roi = 1;
  bool has_roi() const;
  private:
  bool _internal_has_roi() const;
  public:
  void clear_roi();
  const ::proto::Rect& roi() const;
  PROTOBUF_NODISCARD ::proto::Rect* release_roi();
  ::proto::Rect* mutable_roi();
  void set_allocated_roi(::proto::Rect* roi);
  private:
  const ::proto::Rect& _internal_roi() const;
  ::proto::Rect* _internal_mutable_roi();
  public:
  void unsafe_arena_set_allocated_roi(
      ::proto::Rect* roi);
  ::proto::Rect* unsafe_arena_release_roi();

  // .proto.SpatialLocationCalculatorConfigThresholds depthThresholds = 2;
  bool has_depththresholds() const;
  private:
  bool _internal_has_depththresholds() const;
  public:
  void clear_depththresholds();
  const ::proto::SpatialLocationCalculatorConfigThresholds& depththresholds() const;
  PROTOBUF_NODISCARD ::proto::SpatialLocationCalculatorConfigThresholds* release_depththresholds();
  ::proto::SpatialLocationCalculatorConfigThresholds* mutable_depththresholds();
  void set_allocated_depththresholds(::proto::SpatialLocationCalculatorConfigThresholds* depththresholds);
  private:
  const ::proto::SpatialLocationCalculatorConfigThresholds& _internal_depththresholds() const;
  ::proto::SpatialLocationCalculatorConfigThresholds* _internal_mutable_depththresholds();
  public:
  void unsafe_arena_set_allocated_depththresholds(
      ::proto::SpatialLocationCalculatorConfigThresholds* depththresholds);
  ::proto::SpatialLocationCalculatorConfigThresholds* unsafe_arena_release_depththresholds();

  // .proto.SpatialLocationCalculatorAlgorithm calculationAlgorithm = 3;
  void clear_calculationalgorithm();
  ::proto::SpatialLocationCalculatorAlgorithm calculationalgorithm() const;
  void set_calculationalgorithm(::proto::SpatialLocationCalculatorAlgorithm value);
  private:
  ::proto::SpatialLocationCalculatorAlgorithm _internal_calculationalgorithm() const;
  void _internal_set_calculationalgorithm(::proto::SpatialLocationCalculatorAlgorithm value);
  public:

  // int32 stepSize = 4;
  void clear_stepsize();
  int32_t stepsize() const;
  void set_stepsize(int32_t value);
  private:
  int32_t _internal_stepsize() const;
  void _internal_set_stepsize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SpatialLocationCalculatorConfigData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::proto::Rect* roi_;
  ::proto::SpatialLocationCalculatorConfigThresholds* depththresholds_;
  int calculationalgorithm_;
  int32_t stepsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SpatialImgDetections_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Rect) */ {
 public:
  inline Rect() : Rect(nullptr) {}
  ~Rect() override;
  explicit constexpr Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Rect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Rect";
  }
  protected:
  explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float width_;
  float height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SpatialImgDetections_2eproto;
};
// -------------------------------------------------------------------

class SpatialLocationCalculatorConfigThresholds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SpatialLocationCalculatorConfigThresholds) */ {
 public:
  inline SpatialLocationCalculatorConfigThresholds() : SpatialLocationCalculatorConfigThresholds(nullptr) {}
  ~SpatialLocationCalculatorConfigThresholds() override;
  explicit constexpr SpatialLocationCalculatorConfigThresholds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpatialLocationCalculatorConfigThresholds(const SpatialLocationCalculatorConfigThresholds& from);
  SpatialLocationCalculatorConfigThresholds(SpatialLocationCalculatorConfigThresholds&& from) noexcept
    : SpatialLocationCalculatorConfigThresholds() {
    *this = ::std::move(from);
  }

  inline SpatialLocationCalculatorConfigThresholds& operator=(const SpatialLocationCalculatorConfigThresholds& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatialLocationCalculatorConfigThresholds& operator=(SpatialLocationCalculatorConfigThresholds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpatialLocationCalculatorConfigThresholds& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpatialLocationCalculatorConfigThresholds* internal_default_instance() {
    return reinterpret_cast<const SpatialLocationCalculatorConfigThresholds*>(
               &_SpatialLocationCalculatorConfigThresholds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SpatialLocationCalculatorConfigThresholds& a, SpatialLocationCalculatorConfigThresholds& b) {
    a.Swap(&b);
  }
  inline void Swap(SpatialLocationCalculatorConfigThresholds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpatialLocationCalculatorConfigThresholds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpatialLocationCalculatorConfigThresholds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpatialLocationCalculatorConfigThresholds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpatialLocationCalculatorConfigThresholds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpatialLocationCalculatorConfigThresholds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialLocationCalculatorConfigThresholds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SpatialLocationCalculatorConfigThresholds";
  }
  protected:
  explicit SpatialLocationCalculatorConfigThresholds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerThresholdFieldNumber = 1,
    kUpperThresholdFieldNumber = 2,
  };
  // uint32 lowerThreshold = 1;
  void clear_lowerthreshold();
  uint32_t lowerthreshold() const;
  void set_lowerthreshold(uint32_t value);
  private:
  uint32_t _internal_lowerthreshold() const;
  void _internal_set_lowerthreshold(uint32_t value);
  public:

  // uint32 upperThreshold = 2;
  void clear_upperthreshold();
  uint32_t upperthreshold() const;
  void set_upperthreshold(uint32_t value);
  private:
  uint32_t _internal_upperthreshold() const;
  void _internal_set_upperthreshold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SpatialLocationCalculatorConfigThresholds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t lowerthreshold_;
  uint32_t upperthreshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SpatialImgDetections_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SpatialImgDetections

// int64 sequenceNum = 1;
inline void SpatialImgDetections::clear_sequencenum() {
  sequencenum_ = int64_t{0};
}
inline int64_t SpatialImgDetections::_internal_sequencenum() const {
  return sequencenum_;
}
inline int64_t SpatialImgDetections::sequencenum() const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetections.sequenceNum)
  return _internal_sequencenum();
}
inline void SpatialImgDetections::_internal_set_sequencenum(int64_t value) {
  
  sequencenum_ = value;
}
inline void SpatialImgDetections::set_sequencenum(int64_t value) {
  _internal_set_sequencenum(value);
  // @@protoc_insertion_point(field_set:proto.SpatialImgDetections.sequenceNum)
}

// .proto.Timestamp ts = 2;
inline bool SpatialImgDetections::_internal_has_ts() const {
  return this != internal_default_instance() && ts_ != nullptr;
}
inline bool SpatialImgDetections::has_ts() const {
  return _internal_has_ts();
}
inline const ::proto::Timestamp& SpatialImgDetections::_internal_ts() const {
  const ::proto::Timestamp* p = ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Timestamp&>(
      ::proto::_Timestamp_default_instance_);
}
inline const ::proto::Timestamp& SpatialImgDetections::ts() const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetections.ts)
  return _internal_ts();
}
inline void SpatialImgDetections::unsafe_arena_set_allocated_ts(
    ::proto::Timestamp* ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ts_);
  }
  ts_ = ts;
  if (ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialImgDetections.ts)
}
inline ::proto::Timestamp* SpatialImgDetections::release_ts() {
  
  ::proto::Timestamp* temp = ts_;
  ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Timestamp* SpatialImgDetections::unsafe_arena_release_ts() {
  // @@protoc_insertion_point(field_release:proto.SpatialImgDetections.ts)
  
  ::proto::Timestamp* temp = ts_;
  ts_ = nullptr;
  return temp;
}
inline ::proto::Timestamp* SpatialImgDetections::_internal_mutable_ts() {
  
  if (ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Timestamp>(GetArenaForAllocation());
    ts_ = p;
  }
  return ts_;
}
inline ::proto::Timestamp* SpatialImgDetections::mutable_ts() {
  ::proto::Timestamp* _msg = _internal_mutable_ts();
  // @@protoc_insertion_point(field_mutable:proto.SpatialImgDetections.ts)
  return _msg;
}
inline void SpatialImgDetections::set_allocated_ts(::proto::Timestamp* ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ts_);
  }
  if (ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ts));
    if (message_arena != submessage_arena) {
      ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ts, submessage_arena);
    }
    
  } else {
    
  }
  ts_ = ts;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialImgDetections.ts)
}

// .proto.Timestamp tsDevice = 3;
inline bool SpatialImgDetections::_internal_has_tsdevice() const {
  return this != internal_default_instance() && tsdevice_ != nullptr;
}
inline bool SpatialImgDetections::has_tsdevice() const {
  return _internal_has_tsdevice();
}
inline const ::proto::Timestamp& SpatialImgDetections::_internal_tsdevice() const {
  const ::proto::Timestamp* p = tsdevice_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Timestamp&>(
      ::proto::_Timestamp_default_instance_);
}
inline const ::proto::Timestamp& SpatialImgDetections::tsdevice() const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetections.tsDevice)
  return _internal_tsdevice();
}
inline void SpatialImgDetections::unsafe_arena_set_allocated_tsdevice(
    ::proto::Timestamp* tsdevice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tsdevice_);
  }
  tsdevice_ = tsdevice;
  if (tsdevice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialImgDetections.tsDevice)
}
inline ::proto::Timestamp* SpatialImgDetections::release_tsdevice() {
  
  ::proto::Timestamp* temp = tsdevice_;
  tsdevice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Timestamp* SpatialImgDetections::unsafe_arena_release_tsdevice() {
  // @@protoc_insertion_point(field_release:proto.SpatialImgDetections.tsDevice)
  
  ::proto::Timestamp* temp = tsdevice_;
  tsdevice_ = nullptr;
  return temp;
}
inline ::proto::Timestamp* SpatialImgDetections::_internal_mutable_tsdevice() {
  
  if (tsdevice_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Timestamp>(GetArenaForAllocation());
    tsdevice_ = p;
  }
  return tsdevice_;
}
inline ::proto::Timestamp* SpatialImgDetections::mutable_tsdevice() {
  ::proto::Timestamp* _msg = _internal_mutable_tsdevice();
  // @@protoc_insertion_point(field_mutable:proto.SpatialImgDetections.tsDevice)
  return _msg;
}
inline void SpatialImgDetections::set_allocated_tsdevice(::proto::Timestamp* tsdevice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tsdevice_);
  }
  if (tsdevice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tsdevice));
    if (message_arena != submessage_arena) {
      tsdevice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tsdevice, submessage_arena);
    }
    
  } else {
    
  }
  tsdevice_ = tsdevice;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialImgDetections.tsDevice)
}

// repeated .proto.SpatialImgDetection detections = 4;
inline int SpatialImgDetections::_internal_detections_size() const {
  return detections_.size();
}
inline int SpatialImgDetections::detections_size() const {
  return _internal_detections_size();
}
inline void SpatialImgDetections::clear_detections() {
  detections_.Clear();
}
inline ::proto::SpatialImgDetection* SpatialImgDetections::mutable_detections(int index) {
  // @@protoc_insertion_point(field_mutable:proto.SpatialImgDetections.detections)
  return detections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SpatialImgDetection >*
SpatialImgDetections::mutable_detections() {
  // @@protoc_insertion_point(field_mutable_list:proto.SpatialImgDetections.detections)
  return &detections_;
}
inline const ::proto::SpatialImgDetection& SpatialImgDetections::_internal_detections(int index) const {
  return detections_.Get(index);
}
inline const ::proto::SpatialImgDetection& SpatialImgDetections::detections(int index) const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetections.detections)
  return _internal_detections(index);
}
inline ::proto::SpatialImgDetection* SpatialImgDetections::_internal_add_detections() {
  return detections_.Add();
}
inline ::proto::SpatialImgDetection* SpatialImgDetections::add_detections() {
  ::proto::SpatialImgDetection* _add = _internal_add_detections();
  // @@protoc_insertion_point(field_add:proto.SpatialImgDetections.detections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SpatialImgDetection >&
SpatialImgDetections::detections() const {
  // @@protoc_insertion_point(field_list:proto.SpatialImgDetections.detections)
  return detections_;
}

// -------------------------------------------------------------------

// SpatialImgDetection

// .proto.ImgDetection detection = 1;
inline bool SpatialImgDetection::_internal_has_detection() const {
  return this != internal_default_instance() && detection_ != nullptr;
}
inline bool SpatialImgDetection::has_detection() const {
  return _internal_has_detection();
}
inline const ::proto::ImgDetection& SpatialImgDetection::_internal_detection() const {
  const ::proto::ImgDetection* p = detection_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ImgDetection&>(
      ::proto::_ImgDetection_default_instance_);
}
inline const ::proto::ImgDetection& SpatialImgDetection::detection() const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetection.detection)
  return _internal_detection();
}
inline void SpatialImgDetection::unsafe_arena_set_allocated_detection(
    ::proto::ImgDetection* detection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection_);
  }
  detection_ = detection;
  if (detection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialImgDetection.detection)
}
inline ::proto::ImgDetection* SpatialImgDetection::release_detection() {
  
  ::proto::ImgDetection* temp = detection_;
  detection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ImgDetection* SpatialImgDetection::unsafe_arena_release_detection() {
  // @@protoc_insertion_point(field_release:proto.SpatialImgDetection.detection)
  
  ::proto::ImgDetection* temp = detection_;
  detection_ = nullptr;
  return temp;
}
inline ::proto::ImgDetection* SpatialImgDetection::_internal_mutable_detection() {
  
  if (detection_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ImgDetection>(GetArenaForAllocation());
    detection_ = p;
  }
  return detection_;
}
inline ::proto::ImgDetection* SpatialImgDetection::mutable_detection() {
  ::proto::ImgDetection* _msg = _internal_mutable_detection();
  // @@protoc_insertion_point(field_mutable:proto.SpatialImgDetection.detection)
  return _msg;
}
inline void SpatialImgDetection::set_allocated_detection(::proto::ImgDetection* detection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection_);
  }
  if (detection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection));
    if (message_arena != submessage_arena) {
      detection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detection, submessage_arena);
    }
    
  } else {
    
  }
  detection_ = detection;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialImgDetection.detection)
}

// .proto.Point3f spatialCoordinates = 2;
inline bool SpatialImgDetection::_internal_has_spatialcoordinates() const {
  return this != internal_default_instance() && spatialcoordinates_ != nullptr;
}
inline bool SpatialImgDetection::has_spatialcoordinates() const {
  return _internal_has_spatialcoordinates();
}
inline void SpatialImgDetection::clear_spatialcoordinates() {
  if (GetArenaForAllocation() == nullptr && spatialcoordinates_ != nullptr) {
    delete spatialcoordinates_;
  }
  spatialcoordinates_ = nullptr;
}
inline const ::proto::Point3f& SpatialImgDetection::_internal_spatialcoordinates() const {
  const ::proto::Point3f* p = spatialcoordinates_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Point3f&>(
      ::proto::_Point3f_default_instance_);
}
inline const ::proto::Point3f& SpatialImgDetection::spatialcoordinates() const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetection.spatialCoordinates)
  return _internal_spatialcoordinates();
}
inline void SpatialImgDetection::unsafe_arena_set_allocated_spatialcoordinates(
    ::proto::Point3f* spatialcoordinates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spatialcoordinates_);
  }
  spatialcoordinates_ = spatialcoordinates;
  if (spatialcoordinates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialImgDetection.spatialCoordinates)
}
inline ::proto::Point3f* SpatialImgDetection::release_spatialcoordinates() {
  
  ::proto::Point3f* temp = spatialcoordinates_;
  spatialcoordinates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Point3f* SpatialImgDetection::unsafe_arena_release_spatialcoordinates() {
  // @@protoc_insertion_point(field_release:proto.SpatialImgDetection.spatialCoordinates)
  
  ::proto::Point3f* temp = spatialcoordinates_;
  spatialcoordinates_ = nullptr;
  return temp;
}
inline ::proto::Point3f* SpatialImgDetection::_internal_mutable_spatialcoordinates() {
  
  if (spatialcoordinates_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Point3f>(GetArenaForAllocation());
    spatialcoordinates_ = p;
  }
  return spatialcoordinates_;
}
inline ::proto::Point3f* SpatialImgDetection::mutable_spatialcoordinates() {
  ::proto::Point3f* _msg = _internal_mutable_spatialcoordinates();
  // @@protoc_insertion_point(field_mutable:proto.SpatialImgDetection.spatialCoordinates)
  return _msg;
}
inline void SpatialImgDetection::set_allocated_spatialcoordinates(::proto::Point3f* spatialcoordinates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spatialcoordinates_;
  }
  if (spatialcoordinates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::Point3f>::GetOwningArena(spatialcoordinates);
    if (message_arena != submessage_arena) {
      spatialcoordinates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spatialcoordinates, submessage_arena);
    }
    
  } else {
    
  }
  spatialcoordinates_ = spatialcoordinates;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialImgDetection.spatialCoordinates)
}

// .proto.SpatialLocationCalculatorConfigData boundingBoxMapping = 3;
inline bool SpatialImgDetection::_internal_has_boundingboxmapping() const {
  return this != internal_default_instance() && boundingboxmapping_ != nullptr;
}
inline bool SpatialImgDetection::has_boundingboxmapping() const {
  return _internal_has_boundingboxmapping();
}
inline void SpatialImgDetection::clear_boundingboxmapping() {
  if (GetArenaForAllocation() == nullptr && boundingboxmapping_ != nullptr) {
    delete boundingboxmapping_;
  }
  boundingboxmapping_ = nullptr;
}
inline const ::proto::SpatialLocationCalculatorConfigData& SpatialImgDetection::_internal_boundingboxmapping() const {
  const ::proto::SpatialLocationCalculatorConfigData* p = boundingboxmapping_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SpatialLocationCalculatorConfigData&>(
      ::proto::_SpatialLocationCalculatorConfigData_default_instance_);
}
inline const ::proto::SpatialLocationCalculatorConfigData& SpatialImgDetection::boundingboxmapping() const {
  // @@protoc_insertion_point(field_get:proto.SpatialImgDetection.boundingBoxMapping)
  return _internal_boundingboxmapping();
}
inline void SpatialImgDetection::unsafe_arena_set_allocated_boundingboxmapping(
    ::proto::SpatialLocationCalculatorConfigData* boundingboxmapping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(boundingboxmapping_);
  }
  boundingboxmapping_ = boundingboxmapping;
  if (boundingboxmapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialImgDetection.boundingBoxMapping)
}
inline ::proto::SpatialLocationCalculatorConfigData* SpatialImgDetection::release_boundingboxmapping() {
  
  ::proto::SpatialLocationCalculatorConfigData* temp = boundingboxmapping_;
  boundingboxmapping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SpatialLocationCalculatorConfigData* SpatialImgDetection::unsafe_arena_release_boundingboxmapping() {
  // @@protoc_insertion_point(field_release:proto.SpatialImgDetection.boundingBoxMapping)
  
  ::proto::SpatialLocationCalculatorConfigData* temp = boundingboxmapping_;
  boundingboxmapping_ = nullptr;
  return temp;
}
inline ::proto::SpatialLocationCalculatorConfigData* SpatialImgDetection::_internal_mutable_boundingboxmapping() {
  
  if (boundingboxmapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SpatialLocationCalculatorConfigData>(GetArenaForAllocation());
    boundingboxmapping_ = p;
  }
  return boundingboxmapping_;
}
inline ::proto::SpatialLocationCalculatorConfigData* SpatialImgDetection::mutable_boundingboxmapping() {
  ::proto::SpatialLocationCalculatorConfigData* _msg = _internal_mutable_boundingboxmapping();
  // @@protoc_insertion_point(field_mutable:proto.SpatialImgDetection.boundingBoxMapping)
  return _msg;
}
inline void SpatialImgDetection::set_allocated_boundingboxmapping(::proto::SpatialLocationCalculatorConfigData* boundingboxmapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete boundingboxmapping_;
  }
  if (boundingboxmapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::SpatialLocationCalculatorConfigData>::GetOwningArena(boundingboxmapping);
    if (message_arena != submessage_arena) {
      boundingboxmapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundingboxmapping, submessage_arena);
    }
    
  } else {
    
  }
  boundingboxmapping_ = boundingboxmapping;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialImgDetection.boundingBoxMapping)
}

// -------------------------------------------------------------------

// Point3f

// float x = 1;
inline void Point3f::clear_x() {
  x_ = 0;
}
inline float Point3f::_internal_x() const {
  return x_;
}
inline float Point3f::x() const {
  // @@protoc_insertion_point(field_get:proto.Point3f.x)
  return _internal_x();
}
inline void Point3f::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.Point3f.x)
}

// float y = 2;
inline void Point3f::clear_y() {
  y_ = 0;
}
inline float Point3f::_internal_y() const {
  return y_;
}
inline float Point3f::y() const {
  // @@protoc_insertion_point(field_get:proto.Point3f.y)
  return _internal_y();
}
inline void Point3f::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.Point3f.y)
}

// float z = 3;
inline void Point3f::clear_z() {
  z_ = 0;
}
inline float Point3f::_internal_z() const {
  return z_;
}
inline float Point3f::z() const {
  // @@protoc_insertion_point(field_get:proto.Point3f.z)
  return _internal_z();
}
inline void Point3f::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Point3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:proto.Point3f.z)
}

// -------------------------------------------------------------------

// SpatialLocationCalculatorConfigData

// .proto.Rect roi = 1;
inline bool SpatialLocationCalculatorConfigData::_internal_has_roi() const {
  return this != internal_default_instance() && roi_ != nullptr;
}
inline bool SpatialLocationCalculatorConfigData::has_roi() const {
  return _internal_has_roi();
}
inline void SpatialLocationCalculatorConfigData::clear_roi() {
  if (GetArenaForAllocation() == nullptr && roi_ != nullptr) {
    delete roi_;
  }
  roi_ = nullptr;
}
inline const ::proto::Rect& SpatialLocationCalculatorConfigData::_internal_roi() const {
  const ::proto::Rect* p = roi_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Rect&>(
      ::proto::_Rect_default_instance_);
}
inline const ::proto::Rect& SpatialLocationCalculatorConfigData::roi() const {
  // @@protoc_insertion_point(field_get:proto.SpatialLocationCalculatorConfigData.roi)
  return _internal_roi();
}
inline void SpatialLocationCalculatorConfigData::unsafe_arena_set_allocated_roi(
    ::proto::Rect* roi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roi_);
  }
  roi_ = roi;
  if (roi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialLocationCalculatorConfigData.roi)
}
inline ::proto::Rect* SpatialLocationCalculatorConfigData::release_roi() {
  
  ::proto::Rect* temp = roi_;
  roi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Rect* SpatialLocationCalculatorConfigData::unsafe_arena_release_roi() {
  // @@protoc_insertion_point(field_release:proto.SpatialLocationCalculatorConfigData.roi)
  
  ::proto::Rect* temp = roi_;
  roi_ = nullptr;
  return temp;
}
inline ::proto::Rect* SpatialLocationCalculatorConfigData::_internal_mutable_roi() {
  
  if (roi_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Rect>(GetArenaForAllocation());
    roi_ = p;
  }
  return roi_;
}
inline ::proto::Rect* SpatialLocationCalculatorConfigData::mutable_roi() {
  ::proto::Rect* _msg = _internal_mutable_roi();
  // @@protoc_insertion_point(field_mutable:proto.SpatialLocationCalculatorConfigData.roi)
  return _msg;
}
inline void SpatialLocationCalculatorConfigData::set_allocated_roi(::proto::Rect* roi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete roi_;
  }
  if (roi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::Rect>::GetOwningArena(roi);
    if (message_arena != submessage_arena) {
      roi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roi, submessage_arena);
    }
    
  } else {
    
  }
  roi_ = roi;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialLocationCalculatorConfigData.roi)
}

// .proto.SpatialLocationCalculatorConfigThresholds depthThresholds = 2;
inline bool SpatialLocationCalculatorConfigData::_internal_has_depththresholds() const {
  return this != internal_default_instance() && depththresholds_ != nullptr;
}
inline bool SpatialLocationCalculatorConfigData::has_depththresholds() const {
  return _internal_has_depththresholds();
}
inline void SpatialLocationCalculatorConfigData::clear_depththresholds() {
  if (GetArenaForAllocation() == nullptr && depththresholds_ != nullptr) {
    delete depththresholds_;
  }
  depththresholds_ = nullptr;
}
inline const ::proto::SpatialLocationCalculatorConfigThresholds& SpatialLocationCalculatorConfigData::_internal_depththresholds() const {
  const ::proto::SpatialLocationCalculatorConfigThresholds* p = depththresholds_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SpatialLocationCalculatorConfigThresholds&>(
      ::proto::_SpatialLocationCalculatorConfigThresholds_default_instance_);
}
inline const ::proto::SpatialLocationCalculatorConfigThresholds& SpatialLocationCalculatorConfigData::depththresholds() const {
  // @@protoc_insertion_point(field_get:proto.SpatialLocationCalculatorConfigData.depthThresholds)
  return _internal_depththresholds();
}
inline void SpatialLocationCalculatorConfigData::unsafe_arena_set_allocated_depththresholds(
    ::proto::SpatialLocationCalculatorConfigThresholds* depththresholds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(depththresholds_);
  }
  depththresholds_ = depththresholds;
  if (depththresholds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SpatialLocationCalculatorConfigData.depthThresholds)
}
inline ::proto::SpatialLocationCalculatorConfigThresholds* SpatialLocationCalculatorConfigData::release_depththresholds() {
  
  ::proto::SpatialLocationCalculatorConfigThresholds* temp = depththresholds_;
  depththresholds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SpatialLocationCalculatorConfigThresholds* SpatialLocationCalculatorConfigData::unsafe_arena_release_depththresholds() {
  // @@protoc_insertion_point(field_release:proto.SpatialLocationCalculatorConfigData.depthThresholds)
  
  ::proto::SpatialLocationCalculatorConfigThresholds* temp = depththresholds_;
  depththresholds_ = nullptr;
  return temp;
}
inline ::proto::SpatialLocationCalculatorConfigThresholds* SpatialLocationCalculatorConfigData::_internal_mutable_depththresholds() {
  
  if (depththresholds_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SpatialLocationCalculatorConfigThresholds>(GetArenaForAllocation());
    depththresholds_ = p;
  }
  return depththresholds_;
}
inline ::proto::SpatialLocationCalculatorConfigThresholds* SpatialLocationCalculatorConfigData::mutable_depththresholds() {
  ::proto::SpatialLocationCalculatorConfigThresholds* _msg = _internal_mutable_depththresholds();
  // @@protoc_insertion_point(field_mutable:proto.SpatialLocationCalculatorConfigData.depthThresholds)
  return _msg;
}
inline void SpatialLocationCalculatorConfigData::set_allocated_depththresholds(::proto::SpatialLocationCalculatorConfigThresholds* depththresholds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete depththresholds_;
  }
  if (depththresholds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::SpatialLocationCalculatorConfigThresholds>::GetOwningArena(depththresholds);
    if (message_arena != submessage_arena) {
      depththresholds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, depththresholds, submessage_arena);
    }
    
  } else {
    
  }
  depththresholds_ = depththresholds;
  // @@protoc_insertion_point(field_set_allocated:proto.SpatialLocationCalculatorConfigData.depthThresholds)
}

// .proto.SpatialLocationCalculatorAlgorithm calculationAlgorithm = 3;
inline void SpatialLocationCalculatorConfigData::clear_calculationalgorithm() {
  calculationalgorithm_ = 0;
}
inline ::proto::SpatialLocationCalculatorAlgorithm SpatialLocationCalculatorConfigData::_internal_calculationalgorithm() const {
  return static_cast< ::proto::SpatialLocationCalculatorAlgorithm >(calculationalgorithm_);
}
inline ::proto::SpatialLocationCalculatorAlgorithm SpatialLocationCalculatorConfigData::calculationalgorithm() const {
  // @@protoc_insertion_point(field_get:proto.SpatialLocationCalculatorConfigData.calculationAlgorithm)
  return _internal_calculationalgorithm();
}
inline void SpatialLocationCalculatorConfigData::_internal_set_calculationalgorithm(::proto::SpatialLocationCalculatorAlgorithm value) {
  
  calculationalgorithm_ = value;
}
inline void SpatialLocationCalculatorConfigData::set_calculationalgorithm(::proto::SpatialLocationCalculatorAlgorithm value) {
  _internal_set_calculationalgorithm(value);
  // @@protoc_insertion_point(field_set:proto.SpatialLocationCalculatorConfigData.calculationAlgorithm)
}

// int32 stepSize = 4;
inline void SpatialLocationCalculatorConfigData::clear_stepsize() {
  stepsize_ = 0;
}
inline int32_t SpatialLocationCalculatorConfigData::_internal_stepsize() const {
  return stepsize_;
}
inline int32_t SpatialLocationCalculatorConfigData::stepsize() const {
  // @@protoc_insertion_point(field_get:proto.SpatialLocationCalculatorConfigData.stepSize)
  return _internal_stepsize();
}
inline void SpatialLocationCalculatorConfigData::_internal_set_stepsize(int32_t value) {
  
  stepsize_ = value;
}
inline void SpatialLocationCalculatorConfigData::set_stepsize(int32_t value) {
  _internal_set_stepsize(value);
  // @@protoc_insertion_point(field_set:proto.SpatialLocationCalculatorConfigData.stepSize)
}

// -------------------------------------------------------------------

// Rect

// float x = 1;
inline void Rect::clear_x() {
  x_ = 0;
}
inline float Rect::_internal_x() const {
  return x_;
}
inline float Rect::x() const {
  // @@protoc_insertion_point(field_get:proto.Rect.x)
  return _internal_x();
}
inline void Rect::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Rect::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.Rect.x)
}

// float y = 2;
inline void Rect::clear_y() {
  y_ = 0;
}
inline float Rect::_internal_y() const {
  return y_;
}
inline float Rect::y() const {
  // @@protoc_insertion_point(field_get:proto.Rect.y)
  return _internal_y();
}
inline void Rect::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Rect::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.Rect.y)
}

// float width = 3;
inline void Rect::clear_width() {
  width_ = 0;
}
inline float Rect::_internal_width() const {
  return width_;
}
inline float Rect::width() const {
  // @@protoc_insertion_point(field_get:proto.Rect.width)
  return _internal_width();
}
inline void Rect::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Rect::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.Rect.width)
}

// float height = 4;
inline void Rect::clear_height() {
  height_ = 0;
}
inline float Rect::_internal_height() const {
  return height_;
}
inline float Rect::height() const {
  // @@protoc_insertion_point(field_get:proto.Rect.height)
  return _internal_height();
}
inline void Rect::_internal_set_height(float value) {
  
  height_ = value;
}
inline void Rect::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.Rect.height)
}

// -------------------------------------------------------------------

// SpatialLocationCalculatorConfigThresholds

// uint32 lowerThreshold = 1;
inline void SpatialLocationCalculatorConfigThresholds::clear_lowerthreshold() {
  lowerthreshold_ = 0u;
}
inline uint32_t SpatialLocationCalculatorConfigThresholds::_internal_lowerthreshold() const {
  return lowerthreshold_;
}
inline uint32_t SpatialLocationCalculatorConfigThresholds::lowerthreshold() const {
  // @@protoc_insertion_point(field_get:proto.SpatialLocationCalculatorConfigThresholds.lowerThreshold)
  return _internal_lowerthreshold();
}
inline void SpatialLocationCalculatorConfigThresholds::_internal_set_lowerthreshold(uint32_t value) {
  
  lowerthreshold_ = value;
}
inline void SpatialLocationCalculatorConfigThresholds::set_lowerthreshold(uint32_t value) {
  _internal_set_lowerthreshold(value);
  // @@protoc_insertion_point(field_set:proto.SpatialLocationCalculatorConfigThresholds.lowerThreshold)
}

// uint32 upperThreshold = 2;
inline void SpatialLocationCalculatorConfigThresholds::clear_upperthreshold() {
  upperthreshold_ = 0u;
}
inline uint32_t SpatialLocationCalculatorConfigThresholds::_internal_upperthreshold() const {
  return upperthreshold_;
}
inline uint32_t SpatialLocationCalculatorConfigThresholds::upperthreshold() const {
  // @@protoc_insertion_point(field_get:proto.SpatialLocationCalculatorConfigThresholds.upperThreshold)
  return _internal_upperthreshold();
}
inline void SpatialLocationCalculatorConfigThresholds::_internal_set_upperthreshold(uint32_t value) {
  
  upperthreshold_ = value;
}
inline void SpatialLocationCalculatorConfigThresholds::set_upperthreshold(uint32_t value) {
  _internal_set_upperthreshold(value);
  // @@protoc_insertion_point(field_set:proto.SpatialLocationCalculatorConfigThresholds.upperThreshold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::SpatialLocationCalculatorAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::SpatialLocationCalculatorAlgorithm>() {
  return ::proto::SpatialLocationCalculatorAlgorithm_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SpatialImgDetections_2eproto
